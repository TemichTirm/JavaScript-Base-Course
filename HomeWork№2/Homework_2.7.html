<meta charset = "utf-8">
<script>   
    // п.1
    var result = null > 0;  // false
    alert("Результат сравнения null > 0: " + result);
    
    /*В соответствии со спецификацией ECMA, операторы сравнения > и <, для того, чтобы выяснить, истинно или ложно выражение, 
    пропускают его через так называемый абстрактный алгоритм сравнения для отношений.:

    Сравнение x < y, где x и y являются значениями, возвращает true, false или undefined (последнее означает, что хотя бы один из операндов равен NaN). 
    Такое сравнение производится следующим образом:
    1. Вызвать ToPrimitive(x, подсказка Number).
    2. Вызвать ToPrimitive(y, подсказка Number).
    3. Если Тип(Результата(1)) равен String и Тип(Результата(2)) равен String - переход на шаг 16. 
    4. Вызвать ToNumber(Результат(1)).
    5. Вызвать ToNumber(Результат(2)).
    6. Если Результат(4) равен NaN - вернуть undefined.
    7. Если Результат(5) равен NaN - вернуть undefined.
    8. Если Результат(4) и Результат(5) являются одинаковыми числовыми значениями - вернуть false.
    9. Если Результат(4) равен +0 и Результат(5) равен -0 - вернуть false.
    10. Если Результат(4) равен -0 и Результат(5) равен +0 - вернуть false.
    11. Если Результат(4) равен +∞, вернуть false.
    12. Если Результат(5) равен +∞, вернуть true.
    13. Если Результат(5) равен -∞, вернуть false.
    14. Если Результат(4) равен -∞, вернуть true.
    15. Если математическое значение Результата (4) меньше, чем математическое значение Результата(5) 
        (заметим, что эти математические значения оба конечны и не равны нулю) - вернуть true. Иначе вернуть false.
    16. Если Результат(2) является префиксом Результата(1), вернуть false. (Строковое значение p является префиксом строкового значения q, 
        если q может быть результатом конкатенации p и некоторой другой строки r. 
        Отметим, что каждая строка является своим префиксом, т.к. r может быть пустой строкой.)
    17. Если Результат(1) является префиксом Результата(2), вернуть true.
    18. Пусть k - наименьшее неотрицательное число такое, что символ на позиции k Результата(1) отличается от символа на позиции k Результата(2). 
        (Такое k должно существовать, т.к. на данном шаге установлено, что ни одна из строк не является префиксом другой.)
    19. Пусть m - целое, равное юникодному коду символа на позиции k строки Результат(1).
    20. Пусть n - целое, равное юникодному коду символа на позиции k строки Результат(2).
    21. Если m < n, вернуть true. Иначе вернуть false.

    Шаги 1 и 2 предлагают нам вызвать оператор ToPrimitive() для значений null и 0 для того, чтобы привести эти значения к их элементарному типу 
    (к такому, например, как Number или String). В данном случае ни к левой части выражения, null, ни к правой части, 0, никаких преобразований не применяется.
    Шаг 3 алгоритма в данном случае неприменим. На шагах 4 и 5 нужно преобразовать левую и правую части выражения к типу Number - 
    null будет преобразовано в +0, а 0 останется самим собой. Ни одно из этих значений не является NaN, поэтому шаги алгоритма 6 и 7 пропускаются.
    На шаге 8 определяется что значение +0 равно 0, в результате алгоритм возвращает false. 
    */
    
    // п.2
    result = null >= 0;     // true
    alert("Результат сравнения null >= 0: " + result);
    // В данном случае также применяется аналогичный алгоритм, как в п.1, только на шаге 8 возвращается true

    // п.3
    result = null < 0;      // false
    alert("Результат сравнения null >= 0: " + result);
    // Аналогично п. 1

    // п.4
    result = null <= 0;     // true
    alert("Результат сравнения null >= 0: " + result);
    // Аналогично п. 2

    // п.5
    result = null == 0;     // false
    alert("Результат нестрогого равенства null == 0: " + result);

    /*Оператор == использует так называемый абстрактный алгоритм сравнения для равенств, возвращая в результате true или false:

    Сравнение x == y, где x и y являются значениями, возвращает true или false. Такое сравнение производится следующим образом:
    1. Если Тип(x) отличается от Типа(y) - переход на шаг 14.
    2. Если Тип(x) равен Undefined - вернуть true.
    3. Если Тип(x) равен Null - вернуть true.
    4. Если Тип(x) не равен Number - переход на шаг 11.
    5. Если x является NaN - вернуть false.
    6. Если y является NaN - вернуть false.
    7. Если x является таким же числовым значением, что и y, - вернуть true.
    8. Если x равен +0, а y равен -0, вернуть true.
    9. Если x равен -0, а y равен +0, вернуть true.
    10. Вернуть false.
    11. Если Тип(x) равен String - вернуть true, если x и y являются в точности одинаковыми последовательностями символов 
        (имеют одинаковую длину и одинаковые символы в соответствующих позициях). Иначе вернуть false.
    12. Если Тип(x) равен Boolean, вернуть true, если x и y оба равны true или оба равны false. Иначе вернуть false.
    13. Вернуть true, если x и y ссылаются на один и тот же объект или они ссылаются на объекты, которые были объединены вместе 
        (см. раздел 13.1.2). Иначе вернуть false.
    14. Если x равно null, а y равно undefined - вернуть true.
    15. Если x равно undefined, а y равно null - вернуть true.
    16. Если Тип(x) равен Number, а Тип(y) равен String, вернуть результат сравнения x == ToNumber(y).
    17. Если Тип(x) равен String, а Тип(y) равен Number, вернуть результат сравнения ToNumber(x)== y.
    18. Если Тип(x) равен Boolean, вернуть результат сравнения ToNumber(x)== y.
    19. Если Тип(y) равен Boolean, вернуть результат сравнения x == ToNumber(y).
    20. Если Тип(x) - String или Number, а Тип(y) - Object, вернуть результат сравнения x == ToPrimitive(y).
    21. Если Тип(x) - Object, а Тип(y) - String или Number, вернуть результат сравнения ToPrimitive(x)== y.
    22. Вернуть false.
    
    При сравнении null и 0, сразу переходим из шага 1 к шагу 14, так как Тип(x) отличается от Типа(y). Шаги 14-21 тоже к данному случаю не подходят, 
    так как Тип(х) — это null. Наконец, в соответствии с шагом 22, false возвращается как значение по умолчанию!
    */

    // п.6
    result = null === 0;    // false
    alert("Результат строгого равенства null === 0: " + result);
    // Здесь сразу false, т.к. типы сравниваемых значений различны

</script>